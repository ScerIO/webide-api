// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../https
//   ../sandwich-stream

declare module 'vk-io' {
  import VK from 'vk-io/vk';
  import Request from 'vk-io/api/request';
  export * from 'vk-io/errors';
  export * from 'vk-io/structures/contexts';
  export * from 'vk-io/structures/attachments';
  export { captchaTypes } from 'vk-io/utils/constants';
  export { VK, Request };
  export default VK;
}

declare module 'vk-io/vk' {
  import { Agent } from 'https';
  import API from 'vk-io/api';
  import Auth from 'vk-io/auth';
  import Upload from 'vk-io/upload';
  import Collect from 'vk-io/collect';
  import Updates from 'vk-io/updates';
  import Snippets from 'vk-io/snippets';
  import StreamingAPI from 'vk-io/streaming';
  /**
      * Main class
      *
      * @public
      */
  export default class VK {
    options: {
      agent: Agent;
      token: any;
      lang: any;
      login: any;
      phone: any;
      password: any;
      app: any;
      key: any;
      scope: string;
      apiMode: string;
      apiWait: number;
      apiLimit: number;
      apiAttempts: number;
      apiTimeout: number;
      apiHeaders: {
        'User-Agent': string;
      };
      apiExecuteCount: number;
      apiExecuteMethods: string[];
      uploadTimeout: number;
      pollingWait: number;
      pollingAttempts: number;
      pollingGroupId: any;
      webhookPath: any;
      webhookSecret: any;
      webhookConfirmation: any;
      collectAttempts: number;
    };
    api: API;
    auth: Auth;
    upload: Upload;
    collect: Collect;
    updates: Updates;
    snippets: Snippets;
    streaming: StreamingAPI;
    captchaHandler: any;
    twoFactorHandler: any;
    /**
        * Constructor
        *
        * @param {Object} options
        */
    constructor(options?: {});
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Sets options
        *
        * @param {Object} options
        *
        * @return {this}
        */
    setOptions(options: any): this;
    /**
        * Sets token
        *
        * @param {string} token
        *
        * @return {this}
        */
    setToken(token: any): this;
    /**
        * Returns token
        *
        * @return {?string}
        */
    getToken(): any;
    /**
        * Sets captcha handler
        *
        * @param {?Function} handler
        *
        * @return {this}
        *
        * @example
        * 	vk.setCaptchaHandler((payload, retry) => {...});
        */
    setCaptchaHandler(handler: any): this;
    /**
        * Sets two-factor handler
        *
        * @param {?Function} handler
        *
        * @return {this}
        *
        * @example
        * 	vk.setTwoFactorHandler((payload, retry) => {...});
        */
    setTwoFactorHandler(handler: any): this;
  }
}

declare module 'vk-io/api/request' {
  export default class Request {
    /**
        * Constructor
        *
        * @param {string} method
        * @param {Object} params
        */
    constructor(method: any, params?: {});
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Adds attempt
        *
        * @return {number}
        */
    addAttempt(): void;
    /**
        * Returns string to execute
        *
        * @return {string}
        */
    toString(): string;
  }
}

declare module 'vk-io/errors' {
  import VKError from 'vk-io/errors/vk';
  import APIError from 'vk-io/errors/api';
  import AuthError from 'vk-io/errors/auth';
  import UploadError from 'vk-io/errors/upload';
  import CollectError from 'vk-io/errors/collect';
  import UpdatesError from 'vk-io/errors/updates';
  import ExecuteError from 'vk-io/errors/execute';
  import SnippetsError from 'vk-io/errors/snippets';
  import StreamingRuleError from 'vk-io/errors/streaming-rule';
  export { apiErrors, authErrors, uploadErrors, updatesErrors, collectErrors, snippetsErrors } from 'vk-io/utils/constants';
  export { VKError, APIError, AuthError, UploadError, CollectError, UpdatesError, ExecuteError, SnippetsError, StreamingRuleError };
  export default VKError;
}

declare module 'vk-io/structures/contexts' {
  import Context from 'vk-io/structures/contexts/context';
  import VoteContext from 'vk-io/structures/contexts/vote';
  import TypingContext from 'vk-io/structures/contexts/typing';
  import MessageContext from 'vk-io/structures/contexts/message';
  import WallPostContext from 'vk-io/structures/contexts/wall-post';
  import StreamingContext from 'vk-io/structures/contexts/streaming';
  import GroupUserContext from 'vk-io/structures/contexts/group-user';
  import UserOnlineContext from 'vk-io/structures/contexts/user-online';
  import DialogFlagsContext from 'vk-io/structures/contexts/dialog-flags';
  import GroupUpdateContext from 'vk-io/structures/contexts/group-update';
  import GroupMemberContext from 'vk-io/structures/contexts/group-member';
  import MessageAllowContext from 'vk-io/structures/contexts/message-allow';
  import ReadMessagesContext from 'vk-io/structures/contexts/read-messages';
  import MessageFlagsContext from 'vk-io/structures/contexts/message-flags';
  import CommentActionContext from 'vk-io/structures/contexts/comment-action';
  import NewAttachmentsContext from 'vk-io/structures/contexts/new-attachments';
  import RemovedMessagesContext from 'vk-io/structures/contexts/removed-messages';
  export { Context, VoteContext, TypingContext, MessageContext, WallPostContext, StreamingContext, GroupUserContext, UserOnlineContext, GroupUpdateContext, DialogFlagsContext, MessageAllowContext, GroupMemberContext, ReadMessagesContext, MessageFlagsContext, CommentActionContext, NewAttachmentsContext, RemovedMessagesContext };
  export default Context;
}

declare module 'vk-io/structures/attachments' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  import GiftAttachment from 'vk-io/structures/attachments/gift';
  import WallAttachment from 'vk-io/structures/attachments/wall';
  import LinkAttachment from 'vk-io/structures/attachments/link';
  import PhotoAttachment from 'vk-io/structures/attachments/photo';
  import AudioAttachment from 'vk-io/structures/attachments/audio';
  import VideoAttachment from 'vk-io/structures/attachments/video';
  import MarketAttachment from 'vk-io/structures/attachments/market';
  import StickerAttachment from 'vk-io/structures/attachments/sticker';
  import DocumentAttachment from 'vk-io/structures/attachments/document';
  import WallReplyAttachment from 'vk-io/structures/attachments/wall-reply';
  import MarketAlbumAttachment from 'vk-io/structures/attachments/market-album';
  export { Attachment, GiftAttachment, WallAttachment, LinkAttachment, PhotoAttachment, AudioAttachment, VideoAttachment, MarketAttachment, StickerAttachment, DocumentAttachment, WallReplyAttachment, MarketAlbumAttachment };
  export default Attachment;
}

declare module 'vk-io/utils/constants' {
  /**
      * VK API version
      *
      * @type {string}
      */
  export const API_VERSION = "5.73";
  /**
      * Chat peer ID
      *
      * @type {number}
      */
  export const CHAT_PEER = 2000000000;
  /**
      * Blank html redirect
      *
      * @type {string}
      */
  export const CALLBACK_BLANK = "https://oauth.vk.com/blank.html";
  /**
      * User-Agent for standalone auth
      *
      * @type {string}
      */
  export const DESKTOP_USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36";
  /**
      * Minimum time interval api with error
      *
      * @type {number}
      */
  export const MINIMUM_TIME_INTERVAL_API = 1133;
  /**
      * Default options
      *
      * @type {Object}
      *
      * @property {?string} [token]               Access token
      * @property {Agent}   [agent]               HTTPS agent
      * @property {?string} [lang]                The return data language
      *
      * @property {?string} [login]               User login (phone number or email)
      * @property {?string} [phone]               User phone number
      * @property {?string} [password]            User password
      *
      * @property {?number} [app]                 Application ID
      * @property {?number} [key]                 Secret application key
      * @property {?number} [scope]               List of permissions
      *
      * @property {string}  [apiMode]             Query mode (sequential|parallel|parallel_selected)
      * @property {number}  [apiWait]             Time to wait before re-querying
      * @property {number}  [apiLimit]            Requests per second
      * @property {number}  [apiTimeout]          Wait time for one request
      * @property {number}  [apiHeaders]          Headers sent to the API
      * @property {number}  [apiAttempts]         The number of retries at calling
      * @property {number}  [apiExecuteCount]     Number of requests per execute
      * @property {Array}   [apiExecuteMethods]   Methods for call execute (apiMode=parallel-selected)
      *
      * @property {number}  [uploadTimeout]       Wait time for one request
      *
      * @property {number}  [pollingWait]         Time to wait before re-querying
      * @property {number}  [pollingGroupId]      Group ID for polling
      * @property {number}  [pollingAttempts]     The number of retries at calling
      *
      * @property {?string} [webhookPath]         Webhook path
      * @property {?string} [webhookSecret]       Webhook secret key
      * @property {?string} [webhookConfirmation] Webhook confirmation key
      *
      * @property {number}  [collectAttempts]     The number of retries at calling
      */
  export const defaultOptions: {
    token: any;
    agent: any;
    lang: any;
    login: any;
    phone: any;
    password: any;
    app: any;
    key: any;
    scope: string;
    apiMode: string;
    apiWait: number;
    apiLimit: number;
    apiAttempts: number;
    apiTimeout: number;
    apiHeaders: {
      'User-Agent': string;
    };
    apiExecuteCount: number;
    apiExecuteMethods: string[];
    uploadTimeout: number;
    pollingWait: number;
    pollingAttempts: number;
    pollingGroupId: any;
    webhookPath: any;
    webhookSecret: any;
    webhookConfirmation: any;
    collectAttempts: number;
  };
  /**
      * Default extensions for attachments
      *
      * @type {Object}
      */
  export const defaultExtensions: {
    photo: string;
    video: string;
    audio: string;
    voice: string;
    graffiti: string;
  };
  /**
      * Default content type for attachments
      *
      * @type {Object}
      */
  export const defaultContentTypes: {
    photo: string;
    video: string;
    audio: string;
    voice: string;
    graffiti: string;
  };
  /**
      * Sources of captcha
      *
      * @type {Object}
      */
  export const captchaTypes: {};
  /**
      * API error codes
      *
      * @type {Object}
      */
  export const apiErrors: {
    UNKNOWN_ERROR: number;
    APP_SWITCHED_OFF: number;
    UNKNOWN_METHOD: number;
    AUTH_FAILURE: number;
    TOO_MANY_REQUESTS: number;
    SCOPE_NEEDED: number;
    INCORRECT_REQUEST: number;
    TOO_MANY_SIMILAR_ACTIONS: number;
    INTERNAL_ERROR: number;
    RESPONSE_SIZE_TOO_BIG: number;
    CAPTCHA_REQUIRED: number;
    ACCESS_DENIED: number;
    USER_VALIDATION_REQUIRED: number;
    PAGE_BLOCKED: number;
    STANDALONE_ONLY: number;
    STANDALONE_AND_OPEN_API_ONLY: number;
    METHOD_DISABLED: number;
    CONFIRMATION_REQUIRED: number;
    GROUP_TOKEN_NOT_VALID: number;
    APP_TOKEN_NOT_VALID: number;
    WRONG_PARAMETER: number;
    INCORRECT_USER_ID: number;
    ALBUM_ACCESS_DENIED: number;
    AUDIO_ACCESS_DENIED: number;
    GROUP_ACCESS_DENIED: number;
    ALBUM_OVERFLOW: number;
    PAYMENTS_DISABLED: number;
    COMMERCIAL_ACCESS_DENIED: number;
    COMMERCIAL_ERROR: number;
  };
  /**
      * Auth error codes
      *
      * @type {Object}
      */
  export const authErrors: {};
  /**
      * Upload error codes
      *
      * @type {Object}
      */
  export const uploadErrors: {};
  /**
      * Updates error codes
      *
      * @type {Object}
      */
  export const updatesErrors: {};
  /**
      * Collect error codes
      *
      * @type {Object}
      */
  export const collectErrors: {};
  /**
      * Snippets error codes
      *
      * @type {Object}
      */
  export const snippetsErrors: {};
  /**
      * List of user permissions and their bit mask
      *
      * @type {Map}
      */
  export const userScopes: Map<string, number>;
  /**
      * List of group permissions and their bit mask
      *
      * @type {Map}
      */
  export const groupScopes: Map<string, number>;
  /**
      * VK Platforms
      *
      * @type {Map}
      */
  export const platforms: Map<number, string>;
  /**
      * Parse attachments with RegExp
      *
      * @type {RegExp}
      */
  export const parseAttachment: RegExp;
  /**
      * Parse resource with RegExp
      *
      * @type {RegExp}
      */
  export const parseResource: RegExp;
  /**
      * Parse owner resource with RegExp
      *
      * @type {RegExp}
      */
  export const parseOwnerResource: RegExp;
}

declare module 'vk-io/api' {
  import { sequential } from 'vk-io/api/workers';
  /**
      * Working with API methods
      *
      * @public
      */
  export default class API {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Returns the current used API version
        *
        * @return {string}
        */
    readonly API_VERSION: string;
    /**
        * Checks that this is a API method
        *
        * @param {string} method
        *
        * @return {boolean}
        */
    isMethod(method: any): any;
    /**
        * Call execute method
        *
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    execute(params: any): any;
    /**
        * Call execute procedure
        *
        * @param {string} name
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    procedure(name: any, params: any): any;
    /**
        * Call raw method
        *
        * @param {string} method
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    call(method: any, params: any): any;
    /**
        * Adds request for queue
        *
        * @param {Request} request
        *
        * @return {Promise<Object>}
        */
    callWithRequest(request: any): any;
    /**
        * Adds method to queue
        *
        * @param {string} method
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    enqueue(method: any, params: any): any;
    /**
        * Adds an element to the beginning of the queue
        *
        * @param {Request} request
        */
    requeue(request: any): void;
    /**
        * Running queue
        */
    worker(): void;
    /**
        * Calls the api method
        *
        * @param {Object} request
        */
    callMethod(request: any): Promise<void>;
    /**
        * Error API handler
        *
        * @param {Request} request
        * @param {Object} error
        */
    handleError(request: any, error: any): Promise<void>;
    /**
        * Returns request handler
        *
        * @param {string} mode
        *
        * @return {Function}
        */
    getRequestHandler(mode?: string): typeof sequential;
  }
}

declare module 'vk-io/auth' {
  import DirectAuth from 'vk-io/auth/direct';
  import ImplicitFlowUser from 'vk-io/auth/implicit-flow-user';
  import ImplicitFlowGroups from 'vk-io/auth/implicit-flow-groups';
  export default class Auth {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Standalone authorization with login & password
        *
        * @return {ImplicitFlowUser}
        */
    implicitFlowUser(options?: {}): ImplicitFlowUser;
    /**
        * Standalone authorization with login & password for group
        *
        * @param {mixed}  groups
        * @param {Object} options
        *
        * @return {ImplicitFlowGroup}
        */
    implicitFlowGroups(groups: any, options?: {}): ImplicitFlowGroups;
    /**
        * Direct authorization with login & login in user application
        *
        * @return {DirectAuth}
        */
    direct(): DirectAuth;
    /**
        * Direct authorization with login & login in android application
        *
        * @return {DirectAuth}
        */
    androidApp(): DirectAuth;
    /**
        * Direct authorization with login & login in windows application
        *
        * @return {DirectAuth}
        */
    windowsApp(): DirectAuth;
    /**
        * Direct authorization with login & login in windows phone application
        *
        * @return {DirectAuth}
        */
    windowsPhoneApp(): DirectAuth;
    /**
        * Direct authorization with login & login in iphone application
        *
        * @return {DirectAuth}
        */
    iphoneApp(): DirectAuth;
    /**
        * Direct authorization with login & login in ipad application
        *
        * @return {DirectAuth}
        */
    ipadApp(): DirectAuth;
  }
}

declare module 'vk-io/upload' {
  import MultipartStream from 'vk-io/upload/multipart-stream';
  import { PhotoAttachment, AudioAttachment, VideoAttachment, DocumentAttachment } from 'vk-io/structures/attachments';
  export default class Upload {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Uploading photos to an album
        *
        * @param {Object} params
        *
        * @return {Promise<PhotoAttachment[]>}
        */
    photoAlbum(params: any): Promise<any>;
    /**
        * Uploading photos to the wall
        *
        * @param {Object} params
        *
        * @return {Promise<PhotoAttachment>}
        */
    wallPhoto(params: any): Promise<PhotoAttachment>;
    /**
        * Uploading the main photo of a user or community
        *
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    ownerPhoto(params: any): any;
    /**
        * Uploading a photo to a private message
        *
        * @param {Object} params
        *
        * @return {Promise<PhotoAttachment>}
        */
    messagePhoto(params: any): Promise<PhotoAttachment>;
    /**
        * Uploading the main photo for a chat
        *
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    chatPhoto(params: any): any;
    /**
        * Uploading a photo for a product
        *
        * @param {Object} params
        *
        * @return {Promise<PhotoAttachment>}
        */
    marketPhoto(params: any): Promise<PhotoAttachment>;
    /**
        * Uploads a photo for the selection of goods
        *
        * @param {Object} params
        *
        * @return {Promise<PhotoAttachment>}
        */
    marketAlbumPhoto(params: any): Promise<PhotoAttachment>;
    /**
        * Uploads audio
        *
        * @param {Object} params
        *
        * @return {Promise<AudioAttachment>}
        */
    audio(params: any): Promise<AudioAttachment>;
    /**
        * Uploads video
        *
        * @param {Object} params
        *
        * @return {Promise<VideoAttachment>}
        */
    video(params: any): Promise<VideoAttachment>;
    /**
        * Uploads document
        *
        * @param {Object} params
        * @param {Object} options
        *
        * @return {Promise<DocumentAttachment>}
        */
    document(params: any, { attachmentType }?: {
      attachmentType?: any;
    }): Promise<DocumentAttachment>;
    /**
        * Uploads wall document
        *
        * @param {Object} params
        * @param {Object} options
        *
        * @return {Promise<DocumentAttachment>}
        */
    wallDocument(params: any, { attachmentType }?: {
      attachmentType?: any;
    }): Promise<DocumentAttachment>;
    /**
        * Uploads message document
        *
        * @param {Object} params
        * @param {Object} options
        *
        * @return {Promise<DocumentAttachment>}
        */
    messageDocument(params: any, { attachmentType }?: {
      attachmentType?: any;
    }): Promise<DocumentAttachment>;
    /**
        * Uploads audio message
        *
        * @param {Object} params
        *
        * @return {Promise<DocumentAttachment>}
        */
    voice(params: any): Promise<DocumentAttachment>;
    /**
        * Uploads graffiti
        *
        * @param {Object} params
        *
        * @return {Promise<DocumentAttachment>}
        */
    graffiti(params: any): Promise<DocumentAttachment>;
    /**
        * Uploads community cover
        *
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    groupCover(params: any): any;
    /**
        * Uploads photo stories
        *
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    storiesPhoto(params: any): any;
    /**
        * Uploads video stories
        *
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    storiesVideo(params: any): any;
    /**
        * Behavior for the upload method
        *
        * @param {Object} conduct
        * @property [field]          Field name
        * @property [params]         Upload params
        *
        * @property [getServer]      Get server functions
        * @property [serverParams]   Copies server params
        *
        * @property [saveFiles]      Save files functions
        * @property [saveParams]     Copies save params
        *
        * @property [maxFiles]       Max uploaded files for one request
        * @property [attachmentType] Attachment type
        *
        * @return {Promise<Object>}
        */
    conduct({ field, params, getServer, serverParams, saveFiles, saveParams, maxFiles, attachmentType }: {
      field: any;
      params: any;
      getServer: any;
      serverParams?: undefined[];
      saveFiles: any;
      saveParams?: undefined[];
      maxFiles?: number;
      attachmentType: any;
    }): Promise<any>;
    /**
        * Building form data
        *
        * @param {Object} payload
        *
        * @return {Promise}
        */
    buildPayload({ field, sources, maxFiles, attachmentType }: {
      field: any;
      sources: any;
      maxFiles: any;
      attachmentType: any;
    }): Promise<MultipartStream>;
    /**
        * Upload form data
        *
        * @param {URL|string}      url
        * @param {MultipartStream} formData
        * @param {Object}          options
        *
        * @return {Promise<Object>}
        */
    upload(url: any, formData: any, { timeout }?: {
      timeout: any;
    }): Promise<any>;
  }
}

declare module 'vk-io/collect' {
  import Chain from 'vk-io/collect/chain';
  export default class Collect {
    /**
        * constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Returns new Chain instance
        *
        * @return {Chain}
        */
    chain(): Chain;
    /**
        * Call multiple executors
        *
        * @param {string} method
        * @param {Array}  queue
        *
        * @return {Promise<Array>}
        */
    executes(method: any, queue: any): Promise<{
      response: any[];
      errors: any[];
    }>;
  }
}

declare module 'vk-io/updates' {
  export default class Updates {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Checks is started
        *
        * @return {boolean}
        */
    isStarted(): boolean;
    /**
        * Added middleware
        *
        * @param {Function} handler
        *
        * @return {this}
        */
    use(middleware: any): this;
    /**
        * Subscribe to events
        *
        * @param {string[]} events
        * @param {Function} handler
        *
        * @return {this}
        */
    on(events: any, handler: any): this;
    /**
        * Listen text
        *
        * @param {Mixed[]}  condition
        * @param {Function} handler
        *
        * @return {this}
        */
    hear(conditions: any, handler: any): this;
    /**
        * A handler that is called when handlers are not found
        *
        * @param {Function} handler
        *
        * @return {this}
        */
    setHearFallbackHandler(handler: any): this;
    /**
        * Handles longpoll event
        *
        * @param {Array} update
        */
    handlePollingUpdate(update: any): any;
    /**
        * Handles webhook event
        *
        * @param {Object} update
        */
    handleWebhookUpdate(update: any): any;
    /**
        * Starts to poll server
        *
        * @return {Promise}
        */
    startPolling(): Promise<void>;
    /**
        * Starts the webhook server
        *
        * @param {Function} next
        *
        * @return {Promise}
        */
    startWebhook({ tls, path, port, host }: {
      tls: any;
      path: any;
      port: any;
      host: any;
    }, next: any): Promise<void>;
    /**
        * Stopping gets updates
        *
        * @return {Promise}
        */
    stop(): Promise<void>;
    /**
        * Returns webhook callback like http[s] or express
        *
        * @param {string} path
        *
        * @return {Function}
        */
    getWebhookCallback(path?: any): (req: any, res: any, next: any) => void;
    /**
        * Returns the middleware for the webhook under koa
        *
        * @param {Object} options
        *
        * @return {Function}
        */
    getKoaWebhookMiddleware(options?: {}): (context: any, next: any) => Promise<void>;
    /**
        * Starts forever fetch updates  loop
        *
        * @return {Promise}
        */
    startFetchLoop(): Promise<void>;
    /**
        * Gets updates
        *
        * @return {Promise}
        */
    fetchUpdates(): Promise<void>;
    /**
        * Calls up the middleware chain
        *
        * @param {Context} context
        *
        * @return {Promise<void>}
        */
    dispatchMiddleware(context: any): any;
    /**
        * Reloads middleware
        */
    reloadMiddleware(): void;
  }
}

declare module 'vk-io/snippets' {
  export default class Snippets {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Defines the type of object (user, community, application, attachment)
        *
        * @param {string} resource
        *
        * @return {Promise<Object>}
        */
    resolveResource(resource: any): Promise<{
      id: number;
      owner: number;
      type: any;
    } | {
        id: any;
        type: any;
      }>;
  }
}

declare module 'vk-io/streaming' {
  export default class StreamingAPI {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Starts websocket
        *
        * @return {Promise}
        */
    startWebSocket(): Promise<void>;
    /**
        * Stop all connection
        *
        * @return {Promise}
        */
    stop(): Promise<void>;
    /**
        * Processes server messages
        *
        * @param {Object} serviceMessage
        *
        * @return {Promise}
        */
    handleServiceMessage({ message, service_code: code }: {
      message: any;
      service_code: any;
    }): Promise<void>;
    /**
        * Handles events
        *
        * @param {Object} event
        *
        * @return {Promise}
        */
    handleEvent(event: any): Promise<any>;
    /**
        * Executes the HTTP request for rules
        *
        * @param {string} method
        * @param {Object} options
        *
        * @return {Promise<Object>}
        */
    fetchRules(method: any, payload?: {}): Promise<any>;
    /**
        * Returns a list of rules
        *
        * @return {Promise<Array>}
        */
    getRules(): Promise<any>;
    /**
        * Adds a rule
        *
        * @param {Object} rule
        *
        * @return {Promise}
        */
    addRule(rule: any): Promise<any>;
    /**
        * Removes the rule
        *
        * @param {string} tag
        *
        * @return {Promise}
        */
    deleteRule(tag: any): Promise<any>;
    /**
        * Adds a list of rules
        *
        * @param {Array} rules
        *
        * @return {Promise}
        */
    addRules(rules: any): Promise<[{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]>;
    /**
        * Removes all rules
        *
        * @return {Promise}
        */
    deleteRules(): Promise<[{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]>;
  }
}

declare module 'vk-io/errors/vk' {
  /**
      * General error class
      *
      * @public
      */
  export default class VKError extends Error {
    /**
        * Constructor
        *
        * @param {Object} payload
        */
    constructor({ code, message }: {
      code: any;
      message: any;
    });
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Returns property for json
        *
        * @return {Object}
        */
    toJSON(): {};
  }
}

declare module 'vk-io/errors/api' {
  import VKError from 'vk-io/errors/vk';
  export default class APIError extends VKError {
    /**
      * Constructor
      *
      * @param {Object} payload
      */
    constructor(payload: any);
  }
}

declare module 'vk-io/errors/auth' {
  import VKError from 'vk-io/errors/vk';
  export default class AuthError extends VKError {
  }
}

declare module 'vk-io/errors/upload' {
  import VKError from 'vk-io/errors/vk';
  export default class UploadError extends VKError {
  }
}

declare module 'vk-io/errors/collect' {
  import VKError from 'vk-io/errors/vk';
  export default class CollectError extends VKError {
    /**
      * Constructor
      *
      * @param {Object} payload
      */
    constructor({ message, code, errors }: {
      message: any;
      code: any;
      errors: any;
    });
  }
}

declare module 'vk-io/errors/updates' {
  import VKError from 'vk-io/errors/vk';
  export default class UpdatesError extends VKError {
  }
}

declare module 'vk-io/errors/execute' {
  import VKError from 'vk-io/errors/vk';
  export default class ExecuteError extends VKError {
    /**
      * Constructor
      *
      * @param {Object} payload
      */
    constructor(payload: any);
  }
}

declare module 'vk-io/errors/snippets' {
  import VKError from 'vk-io/errors/vk';
  export default class SnippetsError extends VKError {
  }
}

declare module 'vk-io/errors/streaming-rule' {
  import VKError from 'vk-io/errors/vk';
  export default class StreamingRuleError extends VKError {
    /**
      * Constructor
      *
      * @param {Object} payload
      */
    constructor({ message, error_code: code }: {
      message: any;
      error_code: any;
    });
  }
}

declare module 'vk-io/structures/contexts/context' {
  export default class Context {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Checks whether the context of some of these types
        *
        * @param {string[]} types
        *
        * @return {boolean}
        */
    is(types: any): boolean;
  }
}

declare module 'vk-io/structures/contexts/vote' {
  import Context from 'vk-io/structures/contexts/context';
  export default class VoteContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update }: {
      type: any;
      object: any;
    });
    /**
        * Returns the identifier poll
        *
        * @return {number}
        */
    getId(): any;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the identifier owner
        *
        * @return {number}
        */
    getOwnerId(): any;
    /**
        * Returns the identifier option
        *
        * @return {number}
        */
    getOptionId(): any;
  }
}

declare module 'vk-io/structures/contexts/typing' {
  import Context from 'vk-io/structures/contexts/context';
  export default class TypingContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}    vk
        * @param {Array} update
        */
    constructor(vk: any, [eventId, user, extra]: [any, any, any]);
    /**
        * Checks that the message is typed in the dm
        *
        * @return {boolean}
        */
    isDM(): any;
    /**
        * Checks that the message is typed in the chat
        *
        * @return {boolean}
        */
    isChat(): any;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the identifier chat
        *
        * @return {?number}
        */
    getChatId(): any;
  }
}

declare module 'vk-io/structures/contexts/message' {
  import Context from 'vk-io/structures/contexts/context';
  export default class MessageContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, payload: any, { webhookType, pollingType }: {
      webhookType?: null;
      pollingType?: null;
    });
    /**
        * Load message payload
        *
        * @return {Promise}
        */
    loadMessagePayload(): Promise<void>;
    /**
        * Checks for the presence of attachments
        *
        * @param {?string} type
        *
        * @return {boolean}
        */
    hasAttachments(type?: any): any;
    /**
        * Checks if there is text
        *
        * @return {boolean}
        */
    hasText(): boolean;
    /**
        * Checks for forwarded messages
        *
        * @return {boolean}
        */
    hasForwards(): boolean;
    /**
        * Checks if there is text
        *
        * @return {boolean}
        */
    hasGeo(): boolean;
    /**
        * Checks is a DM
        *
        * @return {boolean}
        */
    isDM(): boolean;
    /**
        * Checks is a chat
        *
        * @return {boolean}
        */
    isChat(): boolean;
    /**
        * Checks is a group
        *
        * @return {boolean}
        */
    isGroup(): boolean;
    /**
        * Check is special event
        *
        * @return {boolean}
        */
    isEvent(): boolean;
    /**
        * Checks whether the message is outbox
        *
        * @return {boolean}
        */
    isOutbox(): boolean;
    /**
        * Checks whether the message is inbox
        *
        * @return {boolean}
        */
    isInbox(): boolean;
    /**
        * Checks that the message was deleted
        *
        * @return {boolean}
        */
    isDeleted(): boolean;
    /**
        * Checks whether the message is read
        *
        * @return {boolean}
        */
    isRead(): boolean;
    /**
        * Checks that the message is important
        *
        * @return {boolean}
        */
    isImportant(): boolean;
    /**
        * Returns the identifier message
        *
        * @return {number}
        */
    getId(): any;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the sender identifier
        *
        * @return {number}
        */
    getSenderId(): any;
    /**
        * Returns the identifier chat
        *
        * @return {?number}
        */
    getChatId(): any;
    /**
        * Returns the destination identifier
        *
        * @return {number}
        */
    getPeerId(): any;
    /**
        * Returns the timestamp when this message was created
        *
        * @return {number}
        */
    getTimestamp(): any;
    /**
        * Returns the Date object when this message was created
        *
        * @return {Date}
        */
    getDate(): Date;
    /**
        * Returns the chat title
        *
        * @return {string}
        */
    getTitle(): any;
    /**
        * Returns the text
        *
        * @return {?string}
        */
    getText(): any;
    /**
        * Returns the from
        *
        * @return {Object}
        */
    getFrom(): any;
    /**
        * Returns the forwards messages
        *
        * @return {Object[]}
        */
    getForwards(): any;
    /**
        * Returns geo
        *
        * @return {?Object}
        */
    getGeo(): any;
    /**
        * Returns the attachments
        *
        * @param {?string} type
        *
        * @return {Array}
        */
    getAttachments(type?: any): any;
    /**
        * Returns the event id
        *
        * @type {Object}
        */
    getEventId(): any;
    /**
        * Returns the event name
        *
        * @return {?string}
        */
    getEventType(): any;
    /**
        * Returns the event name
        *
        * @return {?string}
        */
    getEventText(): any;
    /**
        * Gets a link to invite the user to a conversation
        *
        * @param {Object} params
        *
        * @type {Promise<Object>}
        */
    getInviteLink(params?: {}): any;
    /**
        * Edits a message
        *
        * @param {Object} params
        *
        * @return {Promise}
        */
    editMessage(params: any): any;
    /**
        * Edits a message text
        *
        * @param {string} message
        *
        * @return {Promise}
        */
    editMessageText(message: any): Promise<any>;
    /**
        * Sends a message to the current dialog
        *
        * @param {string|Object} text
        * @param {Object}        params
        *
        * @return {Promise}
        */
    send(text: any, params?: {}): any;
    /**
        * Responds to the current message
        *
        * @param {string|Object} text
        * @param {Object}        params
        *
        * @return {Promise}
        */
    reply(text: any, params?: {}): any;
    /**
        * Sends a sticker to the current dialog
        *
        * @param {number} id
        *
        * @return {Promise}
        */
    sendSticker(id: any): any;
    /**
        * Sends a photo to the current dialog
        *
        * @param {mixed}  sourxe
        * @param {Object} params
        *
        * @return {Promise}
        */
    sendPhoto(source: any, params?: {}): Promise<any>;
    /**
        * Sends a document to the current dialog
        *
        * @param {mixed}  sourxe
        * @param {Object} params
        *
        * @return {Promise}
        */
    sendDocument(source: any, params?: {}): Promise<any>;
    /**
        * Sends a voice to the current dialog
        *
        * @param {mixed}  sourxe
        * @param {Object} params
        *
        * @return {Promise}
        */
    sendVoice(source: any, params?: {}): Promise<any>;
    /**
        * Changes the status of typing in the dialog
        *
        * @return {Promise<boolean>}
        */
    setActivity(): Promise<boolean>;
    /**
        * Marks messages as important or removes a mark.
        *
        * @param {Array}  ids
        * @param {Object} options
        *
        * @return {Promise<Array>}
        */
    markAsImportant(ids?: any[], options?: {
      important: number;
    }): Promise<any>;
    /**
        * Deletes the message
        *
        * @param {Array}  ids
        * @param {Object} options
        *
        * @return {Promise<number[]>}
        */
    deleteMessage(ids?: any[], options?: {
      spam: number;
    }): Promise<any>;
    /**
        * Restores the message
        *
        * @return {Promise<boolean>}
        */
    restoreMessage(): Promise<boolean>;
    /**
        * Allows you to join the chat by an invitation link
        *
        * @param {string} params
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    joinChatByInviteLink(link: any, params?: {}): any;
    /**
        * Checks that in a chat
        */
    assertIsChat(): void;
    /**
        * Rename the chat
        *
        * @param {string} title
        *
        * @return {Promise<boolean>}
        */
    renameChat(title: any): Promise<boolean>;
    /**
        * Sets a new image for the chat
        *
        * @param {mixed}  source
        * @param {Object} params
        *
        * @return {Promise<Object>}
        */
    newChatPhoto(source: any, params?: {}): Promise<any>;
    /**
        * Remove the chat photo
        *
        * @return {Promise<boolean>}
        */
    deleteChatPhoto(): Promise<any>;
    /**
        * Invites a new user
        *
        * @param {number} id
        *
        * @return {Promise<boolean>}
        */
    inviteUser(id?: any): Promise<boolean>;
    /**
        * Excludes user
        *
        * @param {number} id
        *
        * @return {Promise<boolean>}
        */
    kickUser(id?: any): Promise<boolean>;
    /**
        * Pins a message
        *
        * @return {Promise<boolean>}
        */
    pinMessage(): Promise<boolean>;
    /**
        * Unpins a message
        *
        * @return {Promise<boolean>}
        */
    unpinMessage(): Promise<boolean>;
  }
}

declare module 'vk-io/structures/contexts/wall-post' {
  import Context from 'vk-io/structures/contexts/context';
  export default class WallPostContext extends Context {
    /**
        * constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update }: {
      type: any;
      object: any;
    });
    /**
        * Checks is repost
        *
        * @return {boolean}
        */
    isRepost(): any;
    /**
        * Returns the wall attachment
        *
        * @return {WallAttachment}
        */
    getWall(): any;
    /**
        * Removes a record from the wall
        *
        * @return {Promise}
        */
    deletePost(): any;
  }
}

declare module 'vk-io/structures/contexts/streaming' {
  import Context from 'vk-io/structures/contexts/context';
  export default class StreamingContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, payload: any);
    /**
        * Checks is new object
        *
        * @return {boolean}
        */
    isNew(): boolean;
    /**
        * Checks is update object
        *
        * @return {boolean}
        */
    isUpdate(): boolean;
    /**
        * Checks is delete object
        *
        * @return {boolean}
        */
    isDelete(): boolean;
    /**
        * Checks is restore object
        *
        * @return {boolean}
        */
    isRestore(): boolean;
    /**
        * Checks is post event
        *
        * @return {boolean}
        */
    isPost(): boolean;
    /**
        * Checks is share event
        *
        * @return {boolean}
        */
    isShare(): boolean;
    /**
        * Checks is comment event
        *
        * @return {boolean}
        */
    isComment(): boolean;
    /**
        * Checks for the presence of attachments
        *
        * @param {?string} type
        *
        * @return {boolean}
        */
    hasAttachments(type?: any): any;
    /**
        * Returns the event URL
        *
        * @return {string}
        */
    getUrl(): any;
    /**
        * Returns the creation time
        *
        * @return {number}
        */
    getDate(): any;
    /**
        * Returns the text of the post
        *
        * @return {string}
        */
    getText(): any;
    /**
        * Returns the attachments
        *
        * @param {?string} type
        *
        * @return {Array}
        */
    getAttachments(type?: any): any;
    /**
        * Returns the text of the shared post
        *
        * @return {?string}
        */
    getSharedText(): any;
    /**
        * Returns the creation time from original post
        *
        * @return {?number}
        */
    getSharedDate(): any;
    /**
        * Returns the action type
        *
        * @return {string}
        */
    getActionType(): any;
    /**
        * Returns the creation time from
        *
        * @return {number}
        */
    getActionDate(): any;
    /**
        * Returns the geo location
        *
        * @return {Object}
        */
    getGeo(): any;
    /**
        * Returns the rule tags
        *
        * @return {Array}
        */
    getTags(): any;
    /**
        * Returns the identifier signer user
        *
        * @return {number}
        */
    getSignerId(): any;
    /**
        * Returns the information of author
        *
        * @return {Object}
        */
    getAuthor(): any;
    /**
        * Returns the identifier author
        *
        * @return {number}
        */
    getAuthorId(): any;
    /**
        * Returns the author url
        *
        * @return {string}
        */
    getAuthorUrl(): any;
    /**
        * Returns the identifier of the author of the original post
        *
        * @return {?number}
        */
    getSharedAuthorId(): any;
    /**
        * Returns the author url of the original post
        *
        * @return {?string}
        */
    getSharedAuthorUrl(): any;
    /**
        * Returns the author platform
        *
        * @return {?string}
        */
    getAuthorPlatform(): string;
  }
}

declare module 'vk-io/structures/contexts/group-user' {
  import Context from 'vk-io/structures/contexts/context';
  export default class GroupUserContext extends Context {
    /**
        * Constructror
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update, group_id: groupId }: {
      type: any;
      object: any;
      group_id: any;
    });
    /**
        * Checks is join user
        *
        * @return {boolean}
        */
    isBlock(): any;
    /**
        * Checks is leave user
        *
        * @return {boolean}
        */
    isUnblock(): any;
    /**
        * Checks that the block has expired
        *
        * @return {?boolean}
        */
    isExpired(): boolean;
    /**
        * Returns the identifier admin
        *
        * @return {?number}
        */
    getAdminId(): any;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the reason for the ban
        *
        * @return {?number}
        */
    getReasonId(): any;
    /**
        * Returns the reason name for the ban
        *
        * @return {?string}
        */
    getReasonName(): string;
    /**
        * Returns the administrator comment to block
        *
        * @return {?string}
        */
    getComment(): any;
    /**
        * Adds a user to the community blacklist
        *
        * @param {Object} params
        *
        * @return {Promise}
        */
    banUser(params: any): any;
    /**
        * Adds a user to the community blacklist
        *
        * @return {Promise}
        */
    unbanUser(): any;
  }
}

declare module 'vk-io/structures/contexts/user-online' {
  import Context from 'vk-io/structures/contexts/context';
  export default class UserOnlineContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}    vk
        * @param {Array} update
        */
    constructor(vk: any, [eventId, user, extra, date]: [any, any, any, any]);
    /**
        * Checks that the user is online
        *
        * @return {boolean}
        */
    isUserOnline(): any;
    /**
        * Checks that the user is online
        *
        * @return {boolean}
        */
    isUserOffline(): any;
    /**
        * Checks that the user has logged out of the network himself
        *
        * @return {boolean}
        */
    isSelfExit(): boolean;
    /**
        * Checks that the user logged out a timeout
        *
        * @return {boolean}
        */
    isTimeoutExit(): boolean;
    /**
        * Returns the date when this event was created
        *
        * @return {number}
        */
    getDate(): any;
    /**
        * Returns the name of the platform from which the user entered
        *
        * @return {?string}
        */
    getPlatformName(): string;
  }
}

declare module 'vk-io/structures/contexts/dialog-flags' {
  import Context from 'vk-io/structures/contexts/context';
  export default class DialogFlagsContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}    vk
        * @param {Array} update
        */
    constructor(vk: any, [eventId, peer, flags]: [any, any, any]);
    /**
        * Checks that an important dialogue
        *
        * @return {boolean}
        */
    isImportant(): boolean;
    /**
        * Checks that the unanswered dialog
        *
        * @return {boolean}
        */
    isUnanswered(): boolean;
    /**
        * Returns the destination identifier
        *
        * @return {number}
        */
    getPeerId(): any;
    /**
        * Returns the values of the flags
        *
        * @return {number}
        */
    getFlags(): any;
    /**
        * Marks the dialog as answered or unchecked.
        *
        * @param {Object} params
        *
        * @return {Promise}
        */
    markAsAnsweredDialog(params: any): any;
    /**
        * Marks the dialog as important or removes the mark
        *
        * @param {Object} params
        *
        * @return {Promise}
        */
    markAsImportantDialog(params: any): any;
  }
}

declare module 'vk-io/structures/contexts/group-update' {
  import Context from 'vk-io/structures/contexts/context';
  export default class GroupUpdateContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update }: {
      type: any;
      object: any;
    });
    /**
        * Checks is change photo
        *
        * @return {boolean}
        */
    isChangePhoto(): any;
    /**
        * Checks is change officers
        *
        * @return {boolean}
        */
    isChangeOfficers(): any;
    /**
        * Checks is change settings
        *
        * @return {boolean}
        */
    isChangeSettings(): any;
    /**
        * Checks for the presence of attachments
        *
        * @param {?string} type
        *
        * @return {boolean}
        */
    hasAttachments(type?: any): any;
    /**
        * Returns the identifier admin
        *
        * @return {?number}
        */
    getAdminId(): any;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the old level permission
        *
        * @return {?number}
        */
    getOldLevel(): any;
    /**
        * Returns the new level permission
        *
        * @return {?number}
        */
    getNewLevel(): any;
    /**
        * Returns the changes settings
        *
        * @return {?Object}
        */
    getChanges(): any;
    /**
        * Returns the attachments
        *
        * @param {?string} type
        *
        * @return {Array}
        */
    getAttachments(type?: any): any;
  }
}

declare module 'vk-io/structures/contexts/group-member' {
  import Context from 'vk-io/structures/contexts/context';
  export default class GroupMemberContext extends Context {
    /**
        * Constructro
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update }: {
      type: any;
      object: any;
    });
    /**
        * Checks is join user
        *
        * @return {boolean}
        */
    isJoin(): any;
    /**
        * Checks is leave user
        *
        * @return {boolean}
        */
    isLeave(): any;
    /**
        * Checks is self leave user
        *
        * @return {?boolean}
        */
    isSelfLeave(): boolean;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the join type
        *
        * @return {?string}
        */
    getJoinType(): any;
  }
}

declare module 'vk-io/structures/contexts/message-allow' {
  import Context from 'vk-io/structures/contexts/context';
  export default class MessageAllowContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        *
        * @return {[type]}
        */
    constructor(vk: any, { type, object: update }: {
      type: any;
      object: any;
    });
    /**
        * Checks that the user has subscribed to messages
        *
        * @return {boolean}
        */
    isSubscribed(): any;
    /**
        * Checks that the user has unsubscribed from the messages
        *
        * @return {boolean}
        */
    isUbsubscribed(): any;
    /**
        * Returns the identifier user
        *
        * @return {number}
        */
    getUserId(): any;
    /**
        * Returns the key
        *
        * @return {?string}
        */
    getKey(): any;
  }
}

declare module 'vk-io/structures/contexts/read-messages' {
  import Context from 'vk-io/structures/contexts/context';
  export default class ReadMessagesContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}    vk
        * @param {Array} update
        */
    constructor(vk: any, [eventId, peer, id]: [any, any, any]);
    /**
        * Checks that inbox messages are read
        *
        * @return {boolean}
        */
    isInbox(): any;
    /**
        * Checks that outbox messages are read
        *
        * @return {boolean}
        */
    isOutbox(): any;
    /**
        * Returns the ID before the message read
        *
        * @return {number}
        */
    getId(): any;
    /**
        * Returns the peer ID
        *
        * @return {number}
        */
    getPeerId(): any;
  }
}

declare module 'vk-io/structures/contexts/message-flags' {
  import Context from 'vk-io/structures/contexts/context';
  export default class MessageFlagsContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}    vk
        * @param {Array} update
        */
    constructor(vk: any, [eventId, id, flags, peer]: [any, any, any, any]);
    /**
        * Verifies that the message is not read
        *
        * @return {boolean}
        */
    isUnread(): boolean;
    /**
        * Checks that the outgoing message
        *
        * @return {boolean}
        */
    isOutbox(): boolean;
    /**
        * Verifies that a reply has been created to the message
        *
        * @return {boolean}
        */
    isReplied(): boolean;
    /**
        * Verifies that the marked message
        *
        * @return {boolean}
        */
    isImportant(): boolean;
    /**
        * Verifies that the message was sent via chat
        *
        * @return {boolean}
        */
    isChat(): boolean;
    /**
        * Verifies that the message was sent by a friend
        *
        * @return {boolean}
        */
    isFriends(): boolean;
    /**
        * Verifies that the message is marked as "Spam"
        *
        * @return {boolean}
        */
    isSpam(): boolean;
    /**
        * Verifies that the message has been deleted (in the Recycle Bin)
        *
        * @return {boolean}
        */
    isDeleted(): boolean;
    /**
        * Verifies that the message was verified by the user for spam
        *
        * @return {boolean}
        */
    isFixed(): boolean;
    /**
        * Verifies that the message contains media content
        *
        * @return {boolean}
        */
    isMedia(): boolean;
    /**
        * Checks that a welcome message from the community
        *
        * @return {boolean}
        */
    isHidden(): boolean;
    /**
        * Returns the message ID
        *
        * @return {number}
        */
    getId(): any;
    /**
        * Returns the destination identifier
        *
        * @return {number}
        */
    getPeerId(): any;
    /**
        * Returns the values of the flags
        *
        * @return {number}
        */
    getFlags(): any;
  }
}

declare module 'vk-io/structures/contexts/comment-action' {
  import Context from 'vk-io/structures/contexts/context';
  export default class CommentActionContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update, group_id: groupId }: {
      type: any;
      object: any;
      group_id: any;
    });
    /**
        * Checks for the presence of attachments
        *
        * @param {?string} type
        *
        * @return {boolean}
        */
    hasAttachments(type?: any): any;
    /**
        * Checks is new comment
        *
        * @return {boolean}
        */
    isNew(): any;
    /**
        * Checks is edit comment
        *
        * @return {boolean}
        */
    isEdit(): any;
    /**
        * Checks is delete comment
        *
        * @return {boolean}
        */
    isDelete(): any;
    /**
        * Checks is restore comment
        *
        * @return {boolean}
        */
    isRestore(): any;
    /**
        * Checks is photo comment
        *
        * @return {boolean}
        */
    isPhotoComment(): any;
    /**
        * Checks is wall comment
        *
        * @return {boolean}
        */
    isWallComment(): any;
    /**
        * Checks is video comment
        *
        * @return {boolean}
        */
    isVideoComment(): any;
    /**
        * Checks is board comment
        *
        * @return {boolean}
        */
    isBoardComment(): any;
    /**
        * Checks is board comment
        *
        * @return {boolean}
        */
    isMarketComment(): any;
    /**
        * Checks is reply comment
        *
        * @return {boolean}
        */
    isReply(): boolean;
    /**
        * Returns the identifier comment
        *
        * @return {number}
        */
    getId(): any;
    /**
        * Returns the identifier reply comment
        *
        * @return {?number}
        */
    getReplyId(): any;
    /**
        * Returns the identifier user
        *
        * @return {?number}
        */
    getUserId(): any;
    /**
        * Returns the identifier reply user
        *
        * @return {?number}
        */
    getReplyUserId(): any;
    /**
        * Returns the identifier of the user who deleted the comment
        *
        * @return {?number}
        */
    getRemoverUserId(): any;
    /**
        * Returns the identifier of object
        *
        * @return {?number}
        */
    getObjectId(): any;
    /**
        * Returns the identifier of owner
        *
        * @return {?number}
        */
    getOwnerId(): any;
    /**
        * Returns the date creation action comment
        *
        * @return {?number}
        */
    getDate(): any;
    /**
        * Returns the text comment
        *
        * @return {?string}
        */
    getText(): any;
    /**
        * Returns the attachments
        *
        * @param {?string} type
        *
        * @return {Array}
        */
    getAttachments(type?: any): any;
    /**
        * Returns the likes
        *
        * @return {?Object}
        */
    getLikes(): any;
    /**
        * Includes from subtype
        *
        * @param {string} type
        *
        * @return {string}
        */
    includesFromSubType(type: any): any;
    /**
        * Edits a comment
        *
        * @param {Object} options
        *
        * @return {Promise}
        */
    editComment(options: any): any;
    /**
        * Removes comment
        *
        * @return {Promise}
        */
    deleteComment(): any;
  }
}

declare module 'vk-io/structures/contexts/new-attachments' {
  import Context from 'vk-io/structures/contexts/context';
  export default class NewAttachmentsContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} payload
        */
    constructor(vk: any, { type, object: update }: {
      type: any;
      object: any;
    });
    /**
        * Checks for the presence of attachments
        *
        * @param {?string} type
        *
        * @return {boolean}
        */
    hasAttachments(type?: any): any;
    /**
        * Returns the attachments
        *
        * @param {?string} type
        *
        * @return {Array}
        */
    getAttachments(type?: any): any;
    /**
        * Checks is attachment photo
        *
        * @return {boolean}
        */
    isPhoto(): any;
    /**
        * Checks is attachment video
        *
        * @return {boolean}
        */
    isVideo(): any;
    /**
        * Checks is attachment audio
        *
        * @return {boolean}
        */
    isAudio(): any;
    /**
        * Removes the attachment
        *
        * @return {Promise}
        */
    deleteAttachment(): any;
  }
}

declare module 'vk-io/structures/contexts/removed-messages' {
  import Context from 'vk-io/structures/contexts/context';
  export default class RemovedMessagesContext extends Context {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Arrray} update
        */
    constructor(vk: any, [eventId, peer, id]: [any, any, any]);
    /**
        * Checks that messages have been deleted
        *
        * @return {boolean}
        */
    isRemoved(): any;
    /**
        * Checks that messages have been restored
        *
        * @return {boolean}
        */
    isRecovery(): any;
    /**
        * Returns the identifier of the message
        *
        * @return {string}
        */
    getId(): any;
    /**
        * Returns the peer ID
        *
        * @return {number}
        */
    getPeerId(): any;
  }
}

declare module 'vk-io/structures/attachments/attachment' {
  export default class Attachment {
    /**
        * Constructor
        *
        * @param {string} type
        * @param {number} owner
        * @param {number} id
        * @param {string} accessKey
        */
    constructor(type: any, owner: any, id: any, accessKey?: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Parse attachment with string
        *
        * @param {string} attachment
        *
        * @return {Attachment}
        */
    static fromString(attachment: any): Attachment;
    /**
        * Returns whether the attachment is filled
        *
        * @return {boolean}
        */
    isFilled(): any;
    /**
        * Returns type attachment
        *
        * @return {string}
        */
    getType(): any;
    /**
        * Returns the identifier owner
        *
        * @return {number}
        */
    getOwnerId(): any;
    /**
        * Returns the identifier attachment
        *
        * @return {number}
        */
    getId(): any;
    /**
        * Checks that the attachment is equivalent with object
        *
        * @param {Attachment} attachment
        *
        * @return {boolean}
        */
    equals(attachment: any): boolean;
    /**
        * Checks that the attachment is equivalent with string
        *
        * @param {string} attachment
        *
        * @return {boolean}
        */
    equalString(attachment: any): boolean;
    /**
        * Returns a string to attach a VK
        *
        * @return {string}
        */
    toString(): string;
  }
}

declare module 'vk-io/structures/attachments/gift' {
  export default class GiftAttachment {
    /**
      * Constructor
      *
      * @param {Object} payload
      * @param {VK}     vk
      */
    constructor(payload: any, vk: any);
  }
}

declare module 'vk-io/structures/attachments/wall' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class WallAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
    /**
        * Checks has comments
        *
        * @return {?boolean}
        */
    hasComments(): boolean;
    /**
        * Checks has ads in post
        *
        * @return {?boolean}
        */
    hasAds(): boolean;
    /**
        * Checks for the presence of attachments
        *
        * @param {?string} type
        *
        * @return {boolean}
        */
    hasAttachments(type?: any): any;
    /**
        * Checks has this user reposted
        *
        * @return {?boolean}
        */
    hasUserReposted(): boolean;
    /**
        * Checks has this user likes
        *
        * @return {?boolean}
        */
    hasUserLike(): boolean;
    /**
        * Checks can the current user comment on the entry
        *
        * @return {?boolean}
        */
    isCanUserCommented(): boolean;
    /**
        * Checks if a community can comment on a post
        *
        * @return {?boolean}
        */
    isCanGroupsCommented(): boolean;
    /**
        * Checks if you can comment on a post
        *
        * @return {?boolean}
        */
    isCanCommented(): boolean;
    /**
        * Checks whether the current user can like the record
        *
        * @return {?boolean}
        */
    isCanLike(): boolean;
    /**
        * hecks whether the current user can repost the record
        *
        * @return {?boolean}
        */
    isCanReposted(): boolean;
    /**
        * Checks is can this user pin post
        *
        * @return {?boolean}
        */
    isCanPin(): boolean;
    /**
        * Checks is can this user delete post
        *
        * @return {?boolean}
        */
    isCanDelete(): boolean;
    /**
        * Checks is can this user edit post
        *
        * @return {?boolean}
        */
    isCanEdit(): boolean;
    /**
        * Checks is can this user edit post
        *
        * @return {?boolean}
        */
    isPinned(): boolean;
    /**
        * Checks is post created only by friends
        *
        * @return {?boolean}
        */
    isFriendsOnly(): boolean;
    /**
        * Returns the timestamp when this post was created
        *
        * @return {number}
        */
    getTimestamp(): any;
    /**
        * Returns the Date object when this post was created
        *
        * @return {?Date}
        */
    getDate(): Date;
    /**
        * Returns the identifier author
        *
        * @return {?number}
        */
    getAuthorId(): any;
    /**
        * Returns the post type
        *
        * @return {?string}
        */
    getPostType(): any;
    /**
        * Returns the post text
        *
        * @return {?string}
        */
    getText(): any;
    /**
        * Returns the attachments
        *
        * @param {?string} type
        *
        * @return {Array}
        */
    getAttachments(type?: any): any;
    /**
        * Returns the administrator identifier that posted the entry
        *
        * @return {?number}
        */
    getCreatedUserId(): any;
    /**
        * The identifier of the record owner, in response to which the current
        *
        * @return {?number}
        */
    getReplyOwnerId(): any;
    /**
        * The identifier of the record in response to which the current one was left.
        *
        * @return {?number}
        */
    getReplyPostId(): any;
    /**
        * Returns author identifier if the entry was published
        * on behalf of the community and signed by the user
        *
        * @return {?number}
        */
    getSignerId(): any;
    /**
        * Returns the number of record views
        *
        * @return {?number}
        */
    getViewsCount(): any;
    /**
        * Returns the geo location
        *
        * @return {?Object}
        */
    getGeo(): any;
    /**
        * Returns the likes info
        *
        * @return {?Object}
        */
    getLikes(): any;
    /**
        * Returns the likes count
        *
        * @return {?number}
        */
    getLikesCount(): any;
    /**
        * Returns the reposts count
        *
        * @return {?number}
        */
    getRepostsCount(): any;
    /**
        * Returns the post source
        *
        * @return {?Object}
        */
    getPostSource(): any;
  }
}

declare module 'vk-io/structures/attachments/link' {
  export default class LinkAttachment {
    /**
      * Constructor
      *
      * @param {Object} payload
      * @param {VK}     vk
      */
    constructor(payload: any, vk: any);
  }
}

declare module 'vk-io/structures/attachments/photo' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class PhotoAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
    /**
        * Returns the ID of the user who uploaded the image
        *
        * @return {?number}
        */
    getUserId(): any;
    /**
        * Returns the ID of the album
        *
        * @return {?number}
        */
    getAlbumId(): any;
    /**
        * Returns the photo text
        *
        * @return {?string}
        */
    getText(): any;
    /**
        * Returns the timestamp when this photo was created
        *
        * @return {number}
        */
    getTimestamp(): any;
    /**
        * Returns the Date object when this photo was created
        *
        * @return {?Date}
        */
    getDate(): Date;
    /**
        * Returns the photo height
        *
        * @return {?number}
        */
    getHeight(): any;
    /**
        * Returns the photo width
        *
        * @return {?number}
        */
    getWidth(): any;
    /**
        * Returns the URL of a small photo
        * (130 or 75)
        *
        * @return {?string}
        */
    getSmallPhoto(): any;
    /**
        * Returns the URL of a medium photo
        * (807 or 604 or less)
        *
        * @return {?string}
        */
    getMediumPhoto(): any;
    /**
        * Returns the URL of a large photo
        * (2560 or 1280 or less)
        *
        * @return {?string}
        */
    getLargePhoto(): any;
  }
}

declare module 'vk-io/structures/attachments/audio' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class AudioAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
    /**
        * Checks whether audio is in high quality
        *
        * @return {?boolean}
        */
    isHq(): boolean;
    /**
        * Returns the artist
        *
        * @return {?string}
        */
    getArtist(): any;
    /**
        * Returns the title
        *
        * @return {?string}
        */
    getTitle(): any;
    /**
        * Returns the duration
        *
        * @return {?number}
        */
    getDuration(): any;
    /**
        * Returns the timestamp when this audio was created
        *
        * @return {?number}
        */
    getTimestamp(): any;
    /**
        * Returns the Date object when this audio was created
        *
        * @return {?Date}
        */
    getDate(): Date;
    /**
        * Returns the URL of the audio
        *
        * @return {?string}
        */
    getUrl(): any;
    /**
        * Returns the ID of the lyric
        *
        * @return {?number}
        */
    getLyricsId(): any;
    /**
        * Returns the ID of the album
        *
        * @return {?number}
        */
    getAlbumId(): any;
    /**
        * Returns the ID of the genre
        *
        * @return {?number}
        */
    getGenreId(): any;
  }
}

declare module 'vk-io/structures/attachments/video' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class VideoAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
    /**
        * Checks whether the video is repeatable
        *
        * @return {?boolean}
        */
    isRepeat(): boolean;
    /**
        * Checks that the user can add a video to himself
        *
        * @return {?boolean}
        */
    isCanAdd(): boolean;
    /**
        * Checks if the user can edit the video
        *
        * @return {?boolean}
        */
    isCanEdit(): boolean;
    /**
        * Checks whether the video is being processed
        *
        * @return {?boolean}
        */
    isProcessing(): boolean;
    /**
        * Checks whether the video is a broadcast
        *
        * @return {?boolean}
        */
    isBroadcast(): boolean;
    /**
        * Checks whether the video is a broadcast
        *
        * @return {?boolean}
        */
    isUpcoming(): boolean;
    /**
        * Returns the title
        *
        * @return {?string}
        */
    getTitle(): any;
    /**
        * Returns the description
        *
        * @return {?string}
        */
    getDescription(): any;
    /**
        * Returns the duration
        *
        * @return {?number}
        */
    getDuration(): any;
    /**
        * Returns the timestamp when this video was created
        *
        * @return {number}
        */
    getTimestamp(): any;
    /**
        * Returns the Date object when this video was created
        *
        * @return {?Date}
        */
    getDate(): Date;
    /**
        * Returns the timestamp when this video was added
        *
        * @return {number}
        */
    getAddingTimestamp(): any;
    /**
        * Returns the Date object when this video was added
        *
        * @return {?Date}
        */
    getAddingDate(): Date;
    /**
        * Returns the count views
        *
        * @return {?number}
        */
    getViewsCount(): any;
    /**
        * Returns the count comments
        *
        * @return {?number}
        */
    getCommentsCount(): any;
    /**
        * Returns the URL of the page with the player
        *
        * @return {?string}
        */
    getPlayer(): any;
    /**
        * Returns the name of the platform (for video recordings added from external sites)
        *
        * @return {?string}
        */
    getPlatformName(): any;
    /**
        * Checks for a boolean value in the property
        *
        * @param {string} name
        *
        * @return {?boolean}
        */
    checkBooleanInProperty(name: any): boolean;
  }
}

declare module 'vk-io/structures/attachments/market' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class MarketAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
  }
}

declare module 'vk-io/structures/attachments/sticker' {
  export default class StickerAttachment {
    /**
      * Constructor
      *
      * @param {Object} payload
      * @param {VK}     vk
      */
    constructor(payload: any, vk: any);
  }
}

declare module 'vk-io/structures/attachments/document' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class DocumentAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
    /**
        * Checks if the document is a text
        *
        * @return {?boolean}
        */
    isText(): boolean;
    /**
        * Checks if the document is a archive
        *
        * @return {?boolean}
        */
    isArchive(): boolean;
    /**
        * Checks if the document is a gif file
        *
        * @return {?boolean}
        */
    isGif(): boolean;
    /**
        * Checks if the document is a image
        *
        * @return {?boolean}
        */
    isImage(): boolean;
    /**
        * Checks if the document is a graffiti
        *
        * @return {?boolean}
        */
    isGraffiti(): boolean;
    /**
        * Checks if the document is a audio
        *
        * @return {?boolean}
        */
    isAudio(): boolean;
    /**
        * Checks if the document is a voice
        *
        * @return {?boolean}
        */
    isVoice(): boolean;
    /**
        * Checks if the document is a video
        *
        * @return {?boolean}
        */
    isVideo(): boolean;
    /**
        * Checks if the document is a book
        *
        * @return {?boolean}
        */
    isBook(): boolean;
    /**
        * Returns the document title
        *
        * @return {?string}
        */
    getTitle(): any;
    /**
        * Returns the timestamp when this document was created
        *
        * @return {number}
        */
    getTimestamp(): any;
    /**
        * Returns the Date object when this document was created
        *
        * @return {?Date}
        */
    getDate(): Date;
    /**
        * Returns the type identifier (1~8)
        *
        * @return {?number}
        */
    getTypeId(): any;
    /**
        * Returns the type name
        *
        * @return {?string}
        */
    getTypeName(): string;
    /**
        * Returns the size in bytes
        *
        * @return {?number}
        */
    getSize(): any;
    /**
        * Returns the extension
        *
        * @return {?string}
        */
    getExtension(): any;
    /**
        * Returns the URL of the document
        *
        * @return {?string}
        */
    getUrl(): any;
    /**
        * Returns the info to preview
        *
        * @return {?Object}
        */
    getPreview(): any;
    /**
        * Checks for a property in preview
        *
        * @param {string} name
        *
        * @return {boolean}
        */
    hasPreviewProperty(name: any): boolean;
  }
}

declare module 'vk-io/structures/attachments/wall-reply' {
  export default class WallReplyAttachment {
    /**
      * Constructor
      *
      * @param {Object} payload
      * @param {VK}     vk
      */
    constructor(payload: any, vk: any);
  }
}

declare module 'vk-io/structures/attachments/market-album' {
  import Attachment from 'vk-io/structures/attachments/attachment';
  export default class MarketAlbumAttachment extends Attachment {
    /**
        * Constructor
        *
        * @param {Object} payload
        * @param {VK}     vk
        */
    constructor(payload: any, vk: any);
    /**
        * Load attachment payload
        *
        * @return {Promise}
        */
    loadAttachmentPayload(): Promise<void>;
  }
}

declare module 'vk-io/api/workers' {
  import parallel from 'vk-io/api/workers/parallel';
  import sequential from 'vk-io/api/workers/sequential';
  import parallelSelected from 'vk-io/api/workers/parallel-selected';
  export { parallel, sequential, parallelSelected };
}

declare module 'vk-io/auth/direct' {
  export default class DirectAuth {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} options
        */
    constructor(vk: any, { app, key, agent, scope, login, phone, password }?: {
      app?: any;
      key?: any;
      agent?: any;
      scope?: any;
      login?: any;
      phone?: any;
      password?: any;
    });
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Executes the HTTP request
        *
        * @param {string} url
        * @param {Object} options
        *
        * @return {Promise<Response>}
        */
    fetch(url: any, options?: {}): any;
    /**
        * Returns permission page
        *
        * @param {Object} query
        *
        * @return {Response}
        */
    getPermissionsPage(query?: {}): any;
    /**
        * Runs authorization
        *
        * @return {Promise<Object>}
        */
    run(): Promise<{
      email: any;
      user: number;
      token: any;
      expires: number;
    }>;
    /**
        * Process captcha
        *
        * @param {Object} payload
        *
        * @return {Response}
        */
    processCaptcha({ captcha_sid: sid, captcha_img: src }: {
      captcha_sid: any;
      captcha_img: any;
    }): Promise<any>;
    /**
        * Process two-factor
        *
        * @param {Object} response
        *
        * @return {Promise<Response>}
        */
    processTwoFactor({ validation_type: validationType, phone_mask: phoneMask }: {
      validation_type: any;
      phone_mask: any;
    }): Promise<any>;
    /**
        * Process security form
        *
        * @param {Response} response
        * @param {Cheerio}  $
        *
        * @return {Promise<Response>}
        */
    processSecurityForm(response: any, $: any): Promise<any>;
  }
}

declare module 'vk-io/auth/implicit-flow-user' {
  import ImplicitFlow from 'vk-io/auth/implicit-flow';
  export default class ImplicitFlowUser extends ImplicitFlow {
    /**
        * Returns permission page
        *
        * @return {Response}
        */
    getPermissionsPage(): any;
    /**
        * Starts authorization
        *
        * @return {Promise<Object>}
        */
    run(): Promise<{
      response: {
        email: string;
        user: number;
        token: string;
        expires: number;
      }
    }>;
  }
}

declare module 'vk-io/auth/implicit-flow-groups' {
  import ImplicitFlow from 'vk-io/auth/implicit-flow';
  export default class ImplicitFlowGroups extends ImplicitFlow {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} options
        */
    constructor(vk: any, options: any);
    /**
        * Returns permission page
        *
        * @param {Array} groups
        *
        * @return {Response}
        */
    getPermissionsPage(): any;
    /**
        * Starts authorization
        *
        * @return {Promise<Array>}
        */
    run(): Promise<{
      response: any
    }>;
  }
}

declare module 'vk-io/upload/multipart-stream' {
  const SandwichStream: any
  export default class MultipartStream extends SandwichStream {
    /**
        * Constructor
        *
        * @param {string} boundary
        */
    constructor(boundary: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Returns boundary
        *
        * @return {string}
        */
    getBoundary(): any;
    /**
        * Adds part
        *
        * @param {Object} part
        */
    addPart(part?: {}): void;
    /**
        * Adds form data
        *
        * @param {string} field
        * @param {mixed}  body
        * @param {Object} options
        */
    append(field: any, body: any, { filename, headers }: {
      filename?: null;
      headers?: {};
    }): void;
  }
}

declare module 'vk-io/collect/chain' {
  export default class Chain {
    /**
        * Constructor
        *
        * @param {VK} vk
        */
    constructor(vk: any);
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Adds method to queue
        *
        * @param {string} method
        * @param {Object} params
        *
        * @return {Promise<mixed>}
        */
    append(method: any, params: any): any;
    /**
        * Promise based
        *
        * @param {Function} thenFn
        * @param {Function} catchFn
        *
        * @return {Promise<Object>}
        */
    then(thenFn: any, catchFn: any): Promise<any[] | {
      response: any[];
      errors: any[];
    }>;
    /**
        * Starts the chain
        *
        * @return {Promise}
        */
    run(): Promise<any[] | {
      response: any[];
      errors: any[];
    }>;
  }
}

declare module 'vk-io/api/workers/parallel' {
  export default function parallel(next: any): Promise<void>;
}

declare module 'vk-io/api/workers/sequential' {
  export default function sequential(next: any): void;
}

declare module 'vk-io/api/workers/parallel-selected' {
  export default function parallelSelected(next: any): Promise<void>;
}

declare module 'vk-io/auth/implicit-flow' {
  export default class ImplicitFlow {
    /**
        * Constructor
        *
        * @param {VK}     vk
        * @param {Object} options
        */
    constructor(vk: any, { app, key, agent, scope, login, phone, password }?: {
      app?: any;
      key?: any;
      agent?: any;
      scope?: any;
      login?: any;
      phone?: any;
      password?: any;
    });
    /**
        * Returns custom tag
        *
        * @return {string}
        */
    readonly [Symbol.toStringTag]: string;
    /**
        * Returns CookieJar
        *
        * @return {CookieJar}
        */
    getCookieJar(): any;
    /**
        * Sets the CookieJar
        *
        * @param {CookieJar} jar
        *
        * @return {this}
        */
    setCookieJar(jar: any): this;
    /**
        * Returns cookie
        *
        * @return {Promise<Object>}
        */
    getCookie(): Promise<{
      'login.vk.com': any;
      'vk.com': any;
    }>;
    /**
        * Executes the HTTP request
        *
        * @param {string} url
        * @param {Object} options
        *
        * @return {Promise<Response>}
        */
    fetch(url: any, options?: {}): any;
    /**
        * Runs authorization
        *
        * @return {Promise<Object>}
        */
    run(): Promise<{
      response: any;
    }>;
    /**
        * Process form auth
        *
        * @param {Response} response
        * @param {Cheerio}  $
        *
        * @return {Promise<Response>}
        */
    processAuthForm(response: any, $: any): Promise<any>;
    /**
        * Process two-factor form
        *
        * @param {Response} response
        * @param {Cheerio}  $
        *
        * @return {Promise<Response>}
        */
    processTwoFactorForm(response: any, $: any): Promise<any>;
    /**
        * Process security form
        *
        * @param {Response} response
        * @param {Cheerio}  $
        *
        * @return {Promise<Response>}
        */
    processSecurityForm(response: any, $: any): Promise<any>;
  }
}

